////
Codificación, idioma, tabla de contenidos, tipo de documento
////
:encoding: utf-8
:lang: es
:toc: right
:toc-title: Tabla de contenidos
:keywords: CI/CD Jenkins Pipelines NodeJs Docker KeystoneJs
:doctype: book
:icons: font

////
/// activar btn:
////
:experimental:

:source-highlighter: rouge
:rouge-linenums-mode: inline

// :highlightjsdir: ./highlight

:figure-caption: Fig.
:imagesdir: images


////
Nombre y título del trabajo
////
= Actividad 8. Integración Continua con Jenkins

Computación en la nube servicios y aplicaciones.
Version 1.0, Abril-2020.
Joaquín Cañadas <jjcanada@ual.es>

// Entrar en modo no numerado de apartados
:numbered!: 

[abstract]
////
COLOCA A CONTINUACION EL RESUMEN
////
Integración Continua con Jenkins.

////
COLOCA A CONTINUACION LOS OBJETIVOS
////
.Objetivos
* Construcción automatizada de proyectos Java basados en Maven usando Jenkins como servidor de Integración Continua
* Diseño de los pasos de construcción con Jenkins Pipelines
* Configurar _Webhooks_ para la integración de GitHub y Jenkins
* Generación y visualización de los informes de evolución del proyecto

.Realización y entrega
****
La realización de estas actividades se realizará de forma individual. Serán la base para actividades posteriores que ser harán en equipo. Cada miembro del equipo debe tener sus ejercicios individuales en el Jenkins del equipo. 
La entrega será mediante el envío de un informe y el acceso al profesor a los servicios configurados, para la revisión y evaluación de los mismos. 
****

// Entrar en modo numerado de apartados
:numbered:



== Introducción a la Integración Continua con Jenkins

https://www.jenkins.io/[Jenkins CI] es un sistema de Integración Continua open source, desarrollado por https://en.wikipedia.org/wiki/Kohsuke_Kawaguchi[Kohsuke Kawaguchi], desarrollador de la ex Sun Microsystems y posteriormente de Oracle. En 2010 fundó CloudBees, empresa que da soporte empresarial de Jenkins.

Jenkins proporciona integración continua en el desarrollo de software, es decir, permite configurar y agendar la ejecución de las tareas que componen toda y/o cada una de las partes que conforman el ciclo de vida de un proyecto. Para dar una idea de esto, basta pensar en los famosos https://en.wikipedia.org/wiki/Daily_build[_night-builds_], los cuales son compilaciones, validaciones y liberaciones de versiones beta que realizan algunos sistemas durante las noches de forma automática sobre lo que han ido trabajando los desarrolladores durante el día.

Jenkins nace como _fork_ del sistema predecesor https://es.wikipedia.org/wiki/Hudson_(software)[Hudson CI], del mismo autor, como alternativa open source desde que Sun  fue adquirida por Oracle y cambiada su licencia.

Jenkins posee una interminable lista de plugins, los cuales le permiten definir tareas que pueden integrarse con herramientas de control de versiones (Subversion, Git, ...), ejecutar proyectos basados en Apache Maven, Apache Ant, Microsoft MSBuild, shell y batch scripts, y muchas otras. Además permite ejecutar tareas adicionales previa y posteriormente a la construcción, como por ejemplo preparar el entorno, realizar un despliegue o compactar y subir binarios a un servidor por SSH.

Para cada proyecto, Jenkins guarda un historial de cambios realizados por build o versión, almacena quién lo realizo y cuales archivos fueron manipulados, y sus comentarios al respecto. 

[TIP]
====
Existen otras muchas herramientas de integración continua y despliegue continuo (CI/CD), como https://travis-ci.org/[Travis CI], https://about.gitlab.com/gitlab-ci/[Gitlab CI], https://circleci.com/[Circle CI], https://semaphoreci.com/[Semaphore CI], https://appveyor.com/[Appveyor], https://azure.microsoft.com/en-gb/services/devops/pipelines/?nav=min[Azure DevOps], y muchas más. 
====

=== Principales características

1. Automatiza la construcción del software, periódicamente o en base a unas condiciones. En proyectos Maven se puede simular una construcción similar a un equipo que sólo tuviese instalado Java y Maven (y el correspondiente sistema operativo); de este modo, se __elimina el perverso efecto de la contaminación de los equipos de desarrollo__.

2. Centraliza la información referida a la construcción del software y al estado y _salud_ del proyecto: 
  - Estado de la construcción.
  - Informes sobre la construcción.
  - Informes sobre las pruebas.
  - _Site_ del proyecto.

3.	Gestiona la interacción con otras herramientas, como por ejemplo [_SonarQube_](https://sonarcloud.io/), de mide de calidad del software.

=== ¿Por qué usarlo?

1. Simplifica significativamente (a un par de clicks y dentro de un entorno web lo que lo hace fácilmente accesible desde cualquier parte) los procesos involucrados en el ciclo de vida de un proyecto, ya sean  simples o repetitivos, largos y complejos como puede ser de generación de binarios, integrando el trabajo de varios desarrolladores, ejecución de pruebas automatizadas, generación de informes, publicación en pagina web, notificación a clientes de versiones beta, etc.

2. Da un marco de simplicidad sobre la integración continua gracias a las diferentes posibilidades de notificaciones de éxitos y errores entre procesos, por lo que con la formación adecuada sobre los mismos se puede asegurar una altísima calidad de software desde el primer día, evitando errores, demoras y a un mínimo coste.

3. Debido a los múltiples sistemas de notificaciones por cual optar (ya sea por mail, chat, slack, twitter, etc), es sencillo estar siempre informado y poder tomar decisiones rápidamente.


=== CI/CD y DevOps

La integración continua forma parte de un proceso más amplio conocido como *entrega continua* o *despliegue continuo* (Continuous Delivery, Continuous Deployment), que además abarca el despliegue automatizado de proyectos en distintos entornos de ejecución. Por ello, frecuentemente en la bibliografía se hace referencia como https://es.wikipedia.org/wiki/CI/CD[*CI/CD*], de sus siglas en inglés: _Continuous Integration_ _and_ _Continuous Delivery_.

CI/CD es una práctica fundamental dentro de la metodología https://es.wikipedia.org/wiki/DevOps[DevOps] en ingeniería del software.  


== Prerrequisitos

Para comenzar a trabajar en esta sesión, será necesario haber realizado las actividades anteriores de JUnit y Maven. Además, se debe disponer de crédito en Azure, y es necesario disponer de una máquina virtual con Jenkins instalado y un usuario con permisos (todo ello realizado en sesiones anteriores). Igualmente, se dispone de usuario en GitHub y los repositorios git en GitHub de los proyectos Java de las sesiones anteriores. También, debes tener una pareja de claves SSH personal en la carpeta `HOME` del usuario de tu equipo (`~`).

[source,subs="verbatim,quotes"]
----
~/.ssh/
├── id_rsa <1>
└── id_rsa.pub <2>
----
<1> clave privada
<2> clave pública


== Instalación de plugins adicionales

Vamos a instalar varios plugins adicionales en Jenkins, si aun no están instalados:  Github integration, Maven Integration, Cobertura,Jacoco (comprobar antes si no están instalados ya), Greenballs, Code Coverage Api, JavaDoc, Warnings Next Generation, Embeddable Build Status Plugin, xUnit, etc.

Haz clic en __Manage Jenkins__ > __Manage Plugins__. En la pestaña __Available__ busca __Github integration__, seleccionaló y pulsa en __Download now and install after restart__.

.Instalación del plugin Github integration
image::jenkins-plugins-github-integration.png[role="thumb", align="center"]

Repite los pasos para los plugins _Maven Integration_, _Cobertura_ __Green Balls__, _JavaDoc_ y _xUnit_.

Necesitaremos visualizar el resultado de la cobertura en Jenkins. Para ello instala el plugin de JaCoCo (Java Code Coverage) y el plugin Code Coverage API.

.Instalación del plugin Jacoco
image::plugins-jacoco-install.png[role="thumb", align="center"]

.Instalación del plugin Code Coverage API
image::plugins-code-coverage-api-install.png[role="thumb", align="center"]

Para visualizar el resultado del análisis estático de código, necesitaremos el plugin https://github.com/jenkinsci/warnings-ng-plugin/blob/master/doc/Documentation.md#declarative-pipeline-configuration[Warnings Next Generation]. Procede de la misma forma.

Instala además el https://plugins.jenkins.io/embeddable-build-status/[Embeddable Build Status Plugin], que nos permitirá visualizar en el archivo README.md del proyecto, o en cualquier otro sitio, un pequeño _badge_ o insignia con el estado de build del proyecto.

._Badge_ con el estado del build
image::badge-build-status.png[role="thumb", align="center"]

Por último, marca __Restart Jenkins__ para completar la instalación. Tras unos segundos, vuelve a iniciar sesión y tendrás los plugins instalados. 

.Reiniciar para completar la instalación
image::jenkins-plugins-restart.png[role="thumb", align="center"]

[TIP]
====
El plugin Embeddable Build Status necesita dar acceso al usuario anónimo en la configuración de seguridad de Jenkins, para que se pueda leer el estado de construcción del proyecto:

.Acceso al usuario anómimo
image::build-status-access.png[role="thumb", align="center"]
====


[IMPORTANT]
====
Además de los plugins, para que la máquina virtual de Jenkins funcione correctamente al aumentar la carga de trabajo, es necesario *añadir memoria Swap* (en disco), al menos *2 Gb*. Aquí tienes los pasos: https://www.digitalocean.com/community/tutorials/how-to-add-swap-space-on-ubuntu-18-04[How To Add Swap Space on Ubuntu 18.04].
====


== Tipos de proyectos en Jenkins

En Jenkins existen varios tipos de proyectos. Al hacer clic en nuevo elemento, aparece la vista de creación de nuevo proyecto, en la que debemos introducir el nombre del proyecto y su tipo. Los 3 principales tipos son:

- *Estilo libre (Freestyle project)*: es el más flexible en su configuración. Permite construir proyectos en cualquier tecnología, en función de las herramientas (tools) y plugins que tengas instalados. Se utiliza cuando deseemos ejecutar fundamentalmente comandos desde la _shell_. En la sesión de despliegue automatizado de la web del equipo (sesión 05) usamos proyectos de este tipo. 

- *Proyecto Maven*: se utiliza para construir proyectos Java basados en Maven. De forma predeterminada incluye un paso en el que añadir los _goals_ de maven que se deseen ejecutar en la construccion del proyecto.

- *Pipeline*: un _pipeline_ o tubería identifica los pasos o fases (_stages_) que se van a ejecutar en el proceso de construcción del proyecto. Cada fase tiene definido cómo se ejecuta, y los resultados que produce. La ejecución de las fases es secuencial, aunque también se pueden configurar fases https://www.jenkins.io/blog/2017/09/25/declarative-1/[en paralelo].  

.Nuevo proyecto. Tipos principales de proyectos
image::001-project-types.png[role="thumb", align="center"]

En esta actividad vamos a construir en Jenkins un proyecto estilo libre en Ant, y los proyectos Java mavenizados de las sesiones anteriores de dos formas: 

  . Utilizando la forma clásica, creando un proyecto tipo Maven.

  . Utilizando la descripción en pases mediante _pipeline_. 

Comencemos por la primera forma.

== Creación de un Proyecto con Ant

Comenzaremos con un ejemplo sencillo en Java denominado ConnectFour. Este proyecto se construye con Ant, y está disponible aquí: 
https://github.com/ualhmis/connect-four.git

[TIP]
====
Este ejercicio ConnectFour debe ser realizado individualmente por cada uno de los miembros del equipo.
====

[TIP]
====
Si deseas hacer cambios, por ejemplo para corregir los tests que fallan, primero _forkea_ el repositorio a tu cuenta de GitHub
====

. Creamos una nueva tarea de tipo estilo libre: el nombre debe ser *connectFour-nombreMiembro*

.Nuevo proyecto estilo libre: Connect-four
image::new-connect-four.png[role="thumb", align="center"]

[start=2]

. Jenkins conecta al repositorio donde están los fuentes para descargarlos. Selecciona Git, y añade esta URL: https://github.com/ualhmis/connect-four.git. Al tratarse de un repositorio público no necesita credenciales.

.Git repositorio URL
image::new-connect-four-git-url.png[role="thumb", align="center"]

[start=3]

. Archivo de construcción (build): en la ejecución de la tarea, elegimos Ant

.Build. Ant
image::new-connect-four-build-ant.png[role="thumb", align="center"]

[start=4]

. Seleccionamos la versión de Ant instalada (no dejar “por defecto” porque da error), y en Destinos escribimos *all*

.Seleccionar Ant version. Targets _all_
image::new-connect-four-build-all.png[role="thumb", align="center"]

[start=4]

. Acciones a ejecutar después: Publicamos los resultados de los test JUnit y la documentación JavaDoc

.Acciones a ejecutar despues: JUnit
image::new-connect-four-postbuild-junit.png[role="thumb", align="center"]

Y añadimos la ruta del archivo con los resultados de los test JUnit en xml: `target/test-results/*.xml`

.Test report XML
image::new-connect-four-postbuild-junit-xml.png[role="thumb", align="center"]

[start=5]
. Igualmente, añadimos otra acción a ejecutar después para JavaDoc

.Javadoc
image::new-connect-four-postbuild-javadoc.png[role="thumb", align="center"]


Y añadimos la ruta donde se han generado los archivos JavaDoc: `target/docs`

.Ruta a Javadoc
image::new-connect-four-postbuild-javadoc-target.png[role="thumb", align="center"]

[start=6]
. Guardamos

. *Construir ahora*. 
Por consola se visualiza el resultado de la ejecución de las tareas Ant configuradas en el archivo `build.xml` del proyecto.


El resultado es bola amarilla, porque fallan un par de tests. 
Para ver una gráfica de resultados de los Test debemos ejecutar al menos 2 construcciones.

.Connect-four: Resultado de la construcción
image::new-connect-four-build-results.png[role="thumb", align="center"]

== Creación de un Proyecto Maven

Para ese ejercicio, cada uno debe usar el repositorio de la práctica 7 donde se ha trabajado con Maven.

. Crea un nuevo proyecto Maven. El nombre debe ser *ej07-maven-nombreMiembro*.

.Nuevo proyecto Maven: sesion07
image::new-maven.png[role="thumb", align="center"]

[start=2]
. Indica la URL del proyecto en Github. Utiliza aquí la URL de tu proyecto de la *práctica 7*.

.URL del proyecto en Github
image::new-maven-github-url.png[role="thumb", align="center"]

[start=3]
. Selecciona Git como control de código fuente. Indica la URL del repositorio. 

.URL del repositorio en Github
image::new-maven-github-repo.png[role="thumb", align="center"]

[WARNING]
====
En caso de que sea un repositorio privado tendrás que proporcionar unas *credenciales*. Aunque *no es recomendable*, puedes introducir tus credenciales usuario/contraseña de Github. Sin embargo, es mejor *usar pareja de claves SSH*, aunque es igual de _mala práctica_ meter tu clave privada personal en Jenkins. Por ello, la _buena práctica_ consiste en *crear una nueva pareja de claves* SSH exclusiva para que Jenkins pueda leer el repositorio privado, añadir la *clave pública* al repositorio en GitHub (exclusivamente al repositorio concreto, no a nuestro usuario de GitHub), y por último añadir la *clave privada* como credencial en Jenkins para que pueda leer ese repositorio privado de GitHub.
====

[start=4]
. En la sección de disparadores de la construcción (build trigers) marca la opción de hook con Github: 

.Build con Github hook
image::new-maven-github-hook.png[role="thumb", align="center"]

[WARNING]
====
Recuerda configurar también el _webhook_ en el repo en GitHub (se hizo ya en la sesión 05).
====

[start=5]
. En la sección de _build_, añade la ruta correcta al archivo `pom.xml` y por último añade los goals: `clean pagkage`


.Build con Maven
image::new-maven-build-goals.png[role="thumb", align="center"]

[start=6]
. Guarda los cambios

. *Construir ahora*. 
Por consola se visualiza el resultado de la ejecución de maven.

En los proyectos Maven, no hace falta configurar la publicación de los test de JUnit, se hace de forma predeterminada a partir de la segunda construcción. 

.Resultados de la construcción
image::new-maven-build-results.png[role="thumb", align="center"]

[start=8]
. Añade los *resultados de la cobertura* obtenidos con *JaCoCO*: entra de nuevo en la configuración del proyecto, en _post-build actions_ añade una acción a ejecutar después y selecciona _Record JaCoCo coverage report_

.Añadir el informe de cobertura con JaCoCO
image::maven-postbuild-jacoco.png[role="thumb", align="center"]

[start=9]
. Configura la ruta correcta a los fuentes: `**/src/`

.Configuración de JaCoCo
image::maven-postbuild-jacoco-config.png[role="thumb", align="center"]

[start=10]
. Guarda los cambios y construye el proyecto. Al actualizar el proyecto verás la gráfica de Cobertura. Si ejecutas un par de builds la gráfica muestra la linea de evolución. 

.Añadir el informe de cobertura con JaCoCo
image::maven-postbuild-jacoco-grafica.png[role="thumb", align="center"]

Y si haces clic en la gráfica, verás el informe detallado.

.Detalle de cobertura con JaCoCo
image::maven-postbuild-jacoco-details.png[role="thumb", align="center"]


== Creación de un Proyecto Pipeline

Para ese ejercicio, cada estudiante debe usar, de nuevo, el repositorio de la práctica 7 donde se ha trabajado con Maven. Vamos a configurar el proyecto Jenkins que construya el mismo repositorio de la sección anterior, pero esta vez vamos a utilizar _pipelines_.

=== Diseño del _pipeline_

. Crea un nuevo proyecto y dale el nombre y selecciona tipo _pipeline_. El nombre debe ser *ej07-pipeline-nombreMiembro*.

. Indica la URL del proyecto en Github. Utiliza aquí la URL de tu proyecto de la *práctica 7*.

. En la sección Pipeline, disponemos de un cuadro de texto en el que añadir la descripción de nuestro pipeline utilizando la sintaxis _declarativa_ que Jenkins proporciona. Vamos a ver cómo hacerlo. 


[source,groovy]
----
pipeline {
  agent any <1>

  tools {
    // Nombre dado a la instalación de Maven en "Global Tool configuration"
    maven "Default Maven" <2>
  }

  stages { <3>
   ... 
  }
}
----
<1> agente o nodo de Jenkins en que ejecuta la construcción del  proyecto. En el ejemplo, `any` indica que se ejecutará cualquier nodo, en nuestro caso será en __master__ ya que es el único nodo que hay definido en nuestro Jenkins.
<2> como herramienta para la construcción se usará maven. Pon aquí el nombre que diste a tu instalación de Maven configurada previamente en Tools Configuration. 
<3> Bloque de `stages`: fases o etapas que conforman el pipeline

A continuación se muestra cómo definir cada fase o _stage_ una a una  dentro del bloque _stages_:

[source,groovy]
----
pipeline {
  agent any 

  tools {
    // Nombre dado a la instalación de Maven en "Tools configuration"
    maven "Default Maven"
  }

  stages { 
    stage('Git fetch') { <1>
      steps {
        // Get some code from a GitHub repository
        git 'https://github.com/ualhmis/MavenEjercicios.git'
      }
    }
    stage('Compile, Test, Package') { <2>
      steps {
        // When necessary, use '-f path-to/pom.xml' to give the path to pom.xml
        // Run goal 'package'. It includes compile, test and package.
        sh "mvn  -f sesion07Maven/pom.xml clean package" <3>
      }
      post { <3>
        // Record the test results and archive the jar file.
        success {
          junit '**/target/surefire-reports/TEST-*.xml'
          archiveArtifacts '**/target/*.jar'
        }
      }
    }
  }
}
----
<1> Fase de descarga del *repositorio git*
<2> Fase de build: *compilación, test y empaquetado* de la aplicación. Se ejecutarán los __goals__ `clean package`: primero se elimina todo lo generado en la construcción anterior, y a continuación se lanza la construcción con `package` tal y como está definida en el archivo `pom.xml`.
<3> Cuando sea necesario, indique el path al archivo `pom.xml` con el parámetro `-f path-to/pom.xml`
<4> Paso *posterior al build*, que guarda los resultados de los test de JUnit para generar la gráfica de evolución de los test. Además, https://www.jenkins.io/doc/pipeline/steps/core/#archiveartifacts-archive-the-artifacts[archiva el empaquetado] `.jar` para que pueda ser descargado posteriormente

.Definición del _pipeline_
image::new-pipeline-definition.png[role="thumb", align="center"]

[start=4]
. Guarda los cambios y construye.

. Tras ejecutar el pipeline, con "Build now", el resultado debe ser el siguiente:

.Resultados del _pipeline_
image::new-pipeline-results.png[role="thumb", align="center"]


=== Informe de Cobertura de código

Para visualizar informe de cobertura en el pipeline, añade las dos siguientes linea al bloque `post`:

[source,groovy]
----
  ...
  success {
    junit '**/target/surefire-reports/TEST-*.xml'
    archiveArtifacts '**/target/*.jar'
    jacoco( <1>
      execPattern: '**/target/jacoco.exec',
      classPattern: '**/target/classes',
      sourcePattern: '**/src/',
      exclusionPattern: '**/test/'
    )
    publishCoverage adapters: [jacocoAdapter('**/target/site/jacoco/jacoco.xml')] <2>
  }
  ...
----

<1> Añade el informe Coverage Trend
<2> Añade el informe Coverage Report

Tras la construcción de nuevo del proyecto, verás la gráfica de los resultados de los test y debajo la gráfica de evolución de cobertura. 

.Resultados de la cobertura
image::new-pipeline-coverage-results.png[role="thumb", align="center"]

=== Análisis estático de código: __Checkstyle__

Para mantener y aumentar la calidad de nuestro código debemos ayudarnos, entre otras herramientas, de técnicas de análisis estático de código. Básicamente, se encargan de buscar defectos en el código sin necesidad de que este se ejecute. En Java una de las más habituales es Checkstyle, aunque hay otras como FindBugs, PMD, y SonarQube que integra a los anteriores. 

Para ejecutar y visualizar el análisis de Checkstyle, añade un nuevo _stage_ ap pipeline: 


[source,groovy]
----
  stage ('Analysis') {
    steps {
	  // Warnings next generation plugin required
	  sh "mvn -f sesion07Maven/pom.xml checkstyle:checkstyle site -DgenerateReports=false"
    }
    post {
      // Record the test results and archive the jar file.
      success {
        recordIssues enabledForFailure: true, tool: checkStyle() 
      }
    }
  }
----

Tras la construcción, el pipeline tiene una nueva fase y además en el menú tenemos acceso al informe de CheckStyle.

.Pipeline con la nueva fase de Análisis
image::new-pipeline-checkstyle-report-dashboard.png[role="thumb", align="center"]

.Detalles del informe de CheckStyle
image::new-pipeline-checkstyle-report-details.png[role="thumb", align="center"]

Como parte del ejercicio, completa por ti mismo la publicación del resto de informes de análisis estático de código generados en la sesión 7. Se publican a través del plugin https://www.jenkins.io/doc/pipeline/steps/warnings-ng/[Warnings Next Generation].

- PMD: añade el _goal_ adecuado en la ejecución de maven y añade la publicación del informe:

[source,groovy]
----
recordIssues enabledForFailure: true, tool: pmdParser() 
----

- CPD: añade la publicación del informe:

[source,groovy]
----
recordIssues enabledForFailure: true, tool: cpd() 
----

- Etc.

.Saber más...
****
Si estás interesado en profundizar en este tema, en la asignatura Procesos de Ingeniería del Software II, de 4º curso, lo estudiareis en profundidad. En cualquier caso, adelanto que es recomendable integrar https://www.sonarqube.org/[SonarQube] con Jenkins, ya que SonarQube realiza un análisis mucho más detallado de la calidad y seguridad del código, realizando tanto análisis estático de código (CheckStyle y otros), como de análisis de seguridad (vulnerabilidades), y definiendo lo que denomina https://docs.sonarqube.org/latest/user-guide/quality-gates/[__Quality Gates__] que permiten definir condiciones que se deben cumplir basadas en los valores de las métricas del proyecto (por ejemplo, que la cobertura de código sea mayor del 80%). Puedes encontrar mucha documentación online sobre cómo hacerlo:

- https://docs.sonarqube.org/latest/setup/get-started-2-minutes/[Instalar SonarQube] como aplicación o como contenedor Docker (recomendado)
- Instalar el plugin https://plugins.jenkins.io/sonar/[SonarQube Scanner for Jenkins]
- https://docs.sonarqube.org/latest/analysis/scan/sonarscanner-for-jenkins/#header-1[Configurar] SonarQube Scanner for Jenkins
- https://docs.sonarqube.org/latest/analysis/scan/sonarscanner-for-jenkins/#header-5[Añadir al pipeline] la fase de análisis de Sonar

Además, Si tu proyecto está en un repositorio público en GitHub, puedes ahorrarte tener que instalar tu propio SonarQube utilizando https://sonarcloud.io/[SonarCloud], el servicio de SonarQube en la nube (SaaS) gratuito para proyectos públicos, con el que evitas tener que instalar y mantener tu propio SonarQube. Incluso puedes configurar SonarCloud y Jenkins para que  https://blog.jdriven.com/2019/08/sonarcloud-github-pull-request-analysis-from-jenkins/[analizar los __pull request__] de tu repositorio y conocer el resultado del análisis de Sonar antes de hacer el __merge__ del pull request.
****



